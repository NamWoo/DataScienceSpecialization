0:00
This next lecture is about reading local what are called flat files. Prime examples are text files, hyper delimited text files, comma delimited text files and so forth. If you've actually already taken the R programming class, you may be able to skip this lecture, because you've already seen how to load it into R. So again, we're gonna go back to the Baltimore fixed camera data. And so, I'm again going to download the data. I'm gonna check to see if the data directory exists. And if it doesn't, I'm gonna create it, then I'm going to download the data with download.file. So now the data has been downloaded from the website and is actually sitting on my computer, it's local data to my computer. So the first thing you might wanna use to load the data is with the read.table() function. And so read.table() is the most common function, because it's the most robust. It allows you the most flexibility in some ways in R. It does require a few more parameters than you would pass to some of the other functions and it can be a little bit slow. So there's actually faster ways if you need to scan through files to find specific elements and we might talk about those later. It reads the data into RAM, so it reads the data into memory. And so if you have a really, really big data setting caused problems unless you read it in chunks. Read.tables() is also probably not the best way to read large datasets in general into R. So the important parameters here are what file you wanna read, weather is has a header? What's the separation between elements, weather it has row names and how many rows do you wanna read? The related functions read.csv and read.csv2 will also be briefly discussed. So if we wanna read the cameraData, we could try just sending it to read.table() just like this. We say, cameraData is gonna be the variable we're going to assign and we're gonna use the read.table command and we're gonna read the file cameras.csv. So the problem that you'll get back immediately is an error. It says, line 1 did not have 13 elements and the reason why is because there's commas separating cameras.csv. But the default for read.table() is to look for a tab delimited file. So if you actually try to look at this variable, cameraData, it doesn't exist, because R wasn't able to read it in. So what we can do instead is read.table() with setting the sep command. So this is the separation, we're gonna set it equal to quotes comma. And so what that does is it says, look through the file and assume that all the different values will be separated by balance. We're also gonna tell it header = TRUE, because the variable names are included at the top of each column in the file. So if we do that and assign the results to cameraData variable and then use the head command, this will look at a top few rows of that file. And so for example, on the first row, now we see that data on the first Camera. It wraps around, because of the way that the slide looks here, but each row has now been read into one row of the cameraData variable. You can also use read.csv in the case that you have a csv file, it automatically sets sep equal to the quote comma and it automatically sets header = TRUE. And so, if you have a CSV file, which is one of the most common flat formats that you'll see for data, you can use the read.csv command. Some more important parameters that you can pass, for example, to read.table is you can tell it quotes. So for example, you can say, whether there are quoted values. If you say, quote = " ", like that. You get no quotes in the file, na.strings tell r what the character is that represents a missing value. So the most typical character that you'll see in our datasets in na, but that character might also be minus 1 or 999, 99 or something else. Nrows tells you how many rows in the file to read. So for example, if you only wanna read the first ten lines of the file, you can use nrows = 10 as one of the arguments to the read.table() function. Skip will also tell you how many lines to skip before you read. So for example, suppose you wanna read the 3rd through the 13th line, you would set skip equal to 2 and nrows = 10. So my experience suggest that the biggest common problem that I see in a lot of files is that you see one of these quotation marks placed in the data value somewhere. So when that happens, R gets confused, because it's not looking for those quotes. And so if you set quote=" ", this often resolves those issues and then you won't have to deal with them. So it's just a helpful tip, whenever you see sort of data sets that aren't getting read in or getting read in as very long vectors, setting this quote variable in that way can be one way to address it.

----

0:00
이 다음 강의는 플랫 파일이라고하는 로컬 읽기에 대한 강의입니다. 주요한 예는 텍스트 파일, 하이퍼 구분 된 텍스트 파일, 쉼표로 구분 된 텍스트 파일 등입니다. 이미 R 프로그래밍 클래스를 이미 사용했다면이 강의를 건너 뛸 수 있습니다. 이미 R에로드하는 방법을 보았 기 때문입니다. 다시 볼티모어 고정 카메라 데이터로 돌아갈 것입니다. 그래서 다시 데이터를 다운로드 할 것입니다. 데이터 디렉토리가 있는지 확인하려고합니다. 그리고 그렇지 않다면 나는 그것을 만들려고합니다. 그런 다음 download.file로 데이터를 다운로드 할 것입니다. 이제 데이터가 웹 사이트에서 다운로드되어 실제로 내 컴퓨터에 저장됩니다. 내 컴퓨터에 로컬 데이터입니다. 따라서 데이터를로드하는 데 사용할 첫 번째 작업은 read.table () 함수를 사용하는 것입니다. read.table ()은 가장 보편적 인 함수이기 때문에 가장 강력합니다. R에서 어떤면에서 가장 융통성이 있습니다. 다른 함수에 전달할 매개 변수보다 몇 가지 매개 변수가 필요하며 약간 느릴 수 있습니다. 따라서 특정 요소를 찾기 위해 파일을 스캔해야하는 경우 실제로 더 빠른 방법이 있습니다. 데이터를 RAM으로 읽어 들여 데이터를 메모리로 읽습니다. 그리고 만약 당신이 정말 큰 데이터 셋팅을했다면 문제를 일으켰습니다. Read.tables ()는 일반적으로 큰 데이터 세트를 R로 읽어들이는 가장 좋은 방법이 아닙니다. 여기 중요한 매개 변수는 날씨를 나타내는 헤더입니다. 요소 사이의 구분은 무엇입니까? 날씨에는 행 이름이 있고 행 수는 몇 개입니까? 관련 함수 인 read.csv 및 read.csv2도 간략하게 설명합니다. 따라서 cameraData를 읽으려는 경우 read.table ()과 같이 보내면됩니다. 우리는 cameraData가 우리가 할당 할 변수가 될 것이며 우리는 read.table 명령을 사용할 것이고 우리는 cameras.csv 파일을 읽을 것입니다. 따라서 즉시 해결해야 할 문제는 오류입니다. 그것은 1 행에는 13 개의 요소가 없었고 이유는 카메라가 쉼표로 분리되어 있기 때문입니다. 그러나 read.table ()의 기본값은 탭으로 구분 된 파일을 찾는 것입니다. 그래서이 변수 cameraData를 실제로 보면 R이 그것을 읽을 수 없기 때문에 존재하지 않습니다. 대신 우리가 할 수있는 것은 sep 명령을 설정하여 read.table ()입니다. 그래서 이것은 별거입니다, 우리는 따옴표와 동등하게 설정할 것입니다. 그리고 그것이하는 것은 파일을 조사하고 모든 다른 값들이 균형에 의해 분리 될 것이라고 가정한다는 것입니다. 변수 이름이 파일의 각 열의 맨 위에 포함되어 있기 때문에 header = TRUE로도 알려줄 것입니다. 따라서이를 수행하고 결과를 cameraData 변수에 할당 한 다음 head 명령을 사용하면 해당 파일의 맨 위 몇 행을 볼 수 있습니다. 예를 들어 첫 번째 행에서 첫 번째 카메라의 데이터를 봅니다. 슬라이드가 여기 보이는 방식으로 인해 랩 어라운드되지만 각 행은 이제 cameraData 변수의 한 행으로 읽혀집니다. csv 파일이있는 경우 read.csv를 사용할 수도 있습니다. 자동으로 sep를 따옴표 쉼표와 같게 설정하고 header = TRUE로 자동 설정합니다. 따라서 데이터를 볼 때 가장 보편적 인 플랫 형식 중 하나 인 CSV 파일이 있다면 read.csv 명령을 사용할 수 있습니다. 예를 들어 read.table과 같이 전달할 수있는 더 중요한 매개 변수는 따옴표로 말할 수 있습니다. 예를 들어, 따옴표로 묶인 값이 있는지 여부를 말할 수 있습니다. 네가 말하면, quote = "", 그렇게. 파일에 따옴표가 없으면 na.strings은 r에 누락 된 값을 나타내는 문자를 알립니다. 그래서 na에서 우리의 데이터 세트에서 볼 수있는 가장 일반적인 캐릭터이지만, 그 캐릭터는 1 또는 999, 99 또는 다른 것일 수도 있습니다. Nrows는 읽어야 할 파일의 행 수를 알려줍니다. 예를 들어 파일의 처음 10 줄만 읽으려면 nrows = 10을 read.table () 함수의 인수 중 하나로 사용할 수 있습니다. 건너 뛰기는 읽 기 전에 건너 뛸 줄 수를 알려줍니다. 예를 들어, 3 행에서 13 행까지 읽으려는 경우 건너 뛰기를 2로 설정하고 nrows = 10으로 설정합니다. 따라서 많은 경험에서 볼 수있는 가장 일반적인 문제는 이러한 따옴표는 어딘가에 데이터 값에 배치됩니다. 그렇게되면, R은 그 따옴표를 찾지 않기 때문에 혼란스러워집니다. 따옴표 = ""로 설정하면이 문제를 해결하기 때문에 문제를 해결할 필요가 없습니다. 따라서 유용한 팁이 있습니다. 매우 긴 벡터로 읽거나 읽지 않는 일종의 데이터 세트를 볼 때마다이 견적 변수를 설정하면이 문제를 해결할 수있는 한 가지 방법이 될 수 있습니다.