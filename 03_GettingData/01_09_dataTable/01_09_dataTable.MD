0:00
This lecture is about the data.table package which is a often faster more memory efficient version of the data frames that you're commonly using when your analyzing data NR. So the data.table inherits from a data frame so all functions that accept that data.frame should work on data.table. And there's a pretty steady set of updates to data that table in case it doesn't work. It's written in C so it can be much, much faster than some of the functions that are done in data.frame. It's much, much faster at subsetting, grouping variables, and updating variables than data frames are but it requires you to learn a little bit of a new syntax so there's a little bit of a learning curve.
0:42
So if we load the data.table package we can create a data frame like this. This is the usual way that we create a data frame. And if we look at that we see it has, you know, three variables, x, y, and z stored in each of the columns. And we can also create a data table, and we create it in exactly the same way. And so we just pass it the arguments for the variables that we want to create. And if you look at the top of that data frame you see it looks very similar to what you would expect if you had created a data frame.
1:14
So one thing that you can do is see all of that data that tables in memory, so you do that with the tables command. It has an s at the end, it's different than the table command. And so what it'll tell you is the name of the data table, how many rows, how many megabytes how many columns and if there's a key. And so I'll talk a little bit more about what I mean by a key in a minute. So the first thing that you might want to be able to do is subset rows and so just like with. Subsetting the rows in the data frame. You can subset with the first spot in the square brackets, before the comma. You can also subset just like you did rows, like you did with the data frame, in a similar way, by accessing a particular element, y, and looking at only the values where y is equal to a.
2:04
One thing that is a little bit different is when you subset with only one index, it subsets based on the rows. So if I do this data table, I take the second or third element, that's going to take the second and third rows that come out of that data table.
2:20
What happens when you try to subset columns, if you just try to subset columns the way you're used to in data frames, this is where they really diverge data table and data frame. It's not actually trying to subset the columns using the same subsetting function that happens with data frame, it does something a little bit different. And so what it's using is expressions to be able to summarize the data in various, different ways. So, any expression is some set of statements that are between curly brackets, like this. So here's an example of an statement that says print ten and then five, and so this actually prints out ten. But when you tell k to print, it just prints out the variable five at the end. So, this will come into a play in a minute when we try to use expressions to summarize data sets.
3:06
So for example, you can, instead of putting an index here in the second part of the brackets, you can actually pass a list of functions that you want to perform where the functions are applied to variables named by columns. So here x is one of the variables in the data table and z is one of the variables in the data table. And note we don't have to use parentheses, or sorry, quotation marks. It will just recognize what the variables. That you're trying to use R. And so, this will report the mean of the x values and the sum of the z values. You can also do that to perform pretty much any function. You can say, for example, get a table of the y values. And so, anytime you pass a list into this second argument, it'll perform those functions and return the values. That's good for summarizing data. Another thing that it does very fast and very memory efficiently is to add a new column. So suppose you wanted to add a new column to your data table where a new column was equal to this z variable squared you can use this command where it's colon equals to add that variable w to the data table. And the nice thing is is usually when you're adding a new variable to a data frame, R will copy over the entire data frame and add a new variable to it, so you get two copies of the the data frame and memory. So when dealing with big data sets, this is obviously going to cause lots of memory problems, which you don't have with data table because a new copy isn't being created.
4:34
You have to be a little bit careful with that though, so suppose we set a second data table to be assigned to the first data table. And then we make a change to the first data table. Because a copy hasn't been made, if we go back and look at the first data table, obviously we've made a change to that, we've changed the Y variable to be all equal to's. But the second data table was assigned to be the first data table and since a copy wasn't made, we've actually changed data table two as well. So you have to be able to, if you're trying to create a copy you have to explicitly do that with the copy function. So if you use the function copy you'd be able to copy the data table over.
5:16
So the next thing that you can do is you can actually perform multiple step functions to create new variables. So for example here I have an expression. See it starts with the curly bracket and it ends with a curly bracket. And each statement is followed by a semi-colon. So the first statement is I'm going to assign to the temporary variable, the values of X plus Z, and then I'm going to take the log base two of that temporary variable plus five. And so as you remember, the last thing that gets returned from this expression in the evaluation of this last statement.
5:51
And so what ends up happening is this variable m will be assigned to be log base two of x plus z plus five. So those sorts of multi step operations can be handled very easily with data table.
6:06
You can also do plyr like operations. So for example we can add to this data table a variable like A which is created in zero, equal to true when X is greater than zero and false when X is less than zero. So now we have a binary value A that we can work with. So suppose we want to summarize another variable by the cases where when X is greater than 0 versus the cases where X is less than 0. So for example we can take the mean of X + W and we can do it grouped by a variable A. And so what that's gonna do is it's gonna take the mean of X plus W when A is equal to true, and it's gonna place that mean in all the rows where A is equal to true.
6:51
Then it's gonna take the mean of X plus W where A is equal to false. And place that mean in all the rows where A is equal to false. So it creates a new variable that's equal to the aggregated mean, aggregated over the variable that you used by 4. There's some special variables and data table that allow you to do something's really fast. So one is a .N is an integer linked one and it's a containment number of times that a particular group appears and so for example if I created data table that has a large number of As, Bs, and Cs in it, so about 100,000 A B and Cs. Then what I can do is, if I want to count the number of times each of those letters appear I can use data table, dot N, and then grouped by the X variable. And then what that will do is it will count, dot N is just count the number of times grouped by the X variable.
7:52
It does that very fast as opposed to the equivalent operation, which is just doing that table of DT dollar sign X. A unique aspect of data tables is that they have keys, so if you set the key, it's possible to subset and sort a data table much more rapidly than you would be able to do with a data frame. Here, I'm going to create a data table, and it's going to have a variable X. And it's gonna have a variable Y and I'm gonna set the key for the data table to be the variable X. Then if I want a subset on the basis of x or if I put in quoted a here, it knows to go and look in the key, and the key is x, and it very quickly subsets the data to only the values of x that are equal to a.
8:38
You can also use keys to facilitate joints between data tables so for example here I've created two data tables where they have a variable X and a variable Y and in this case the second data table has a variable Z.
8:57
And so I can set the key in both cases to be equal to x, so the same key for both data tables. And then I can merge them together. This is actually quite a bit faster than merging with the data frame as long as you have the same key for both data tables. It can be very fast.
9:17
It can also be advantageous to use data tables if you want to be able to read things fast from the disk. So here I've created a big data frames. So it's a data frame with two very large variables in it. And then I set up a temporary file with this command right here. And I write our big data frame apps that file. Then I'm going to time how long it takes to read it in using the fread command. The fread command could be applied to reading data tables, just like basically a drop-in substitute for read.table tab separated files. And so you can see it takes about .32 seconds.
9:57
If I tried to do that same operation, if I just tried to read that table that file, it would come in quite a bit slower, well a little more than ten times slower to be able to read that file in. So it's actually much faster to read files with data, data.table as well.
10:14
To summarize data table can be both faster and more memory efficient than data frames. Although it requires you to learn a little bit of use syntax, and sometimes to be a little bit careful in terms of copying over data tables. The latest developments can be found on the development version of the package. Which can be found at this website right here. They've already started to develop a melt like operations and decast like operations for data tables and they're gonna continually update that packages it's a very rapidly developing package. And then this website here is very nice cause it gives you comprehensive-ish list of all the differences between data.table and data frames. And so, that would be very useful if you're transitioning from using data frames to using data table.
10:59
The notes that I've used today are very largely based on the notes that Raphael Gottardo has put up here on GitHub, and they were originally from Kevin Ushey, and I think that both of them deserve credit for the excellent notes that I've largely copied here for this lecture.


----

0:00
는 데이터 프레임 때 데이터 NR분석하고 당신은 일반적으로 사용하는 종종 더 빨리 기억 효율적인 버전은 이 강의는 강의에 대한data.table 패키지이다. 그래서data.table.데이터 프레임에서 상속하는 그래서 그 data.frame을 받아들이는 모든 기능을data.table을 강구해야 한다. 그리고 그것이 작동하지 않을 경우에 대비하여 그 테이블에 대한 꽤 꾸준한 업데이트들이 있다. 그것은 C로 쓰여져 있어서 data.framework에서 행해지는 일부 기능보다 훨씬 더 빠를 수 있다. 데이터 프레임보다 부분 집합화, 변수 그룹화, 변수 업데이트에 있어서 훨씬 더 빠르지만 새로운 구문을 조금 배워야 하기 때문에 학습 곡선이 조금 있다.
0:42
그래서 만약 우리가 data.table 패키지를 로드한다면 우리는 이와 같은 데이터 프레임을 만들 수 있다. 이것이 우리가 데이터 프레임을 만드는 일반적인 방법이다. 우리가 그것을 보면, 각각의 열에 x, y, z라는 세 개의 변수가 저장되어 있는 것을 알 수 있다. 그리고 우리는 또한 데이터 테이블을 만들 수 있고, 정확히 같은 방법으로 만들 수 있다. 그래서 우리는 우리가 만들고자 하는 변수들에 대한 논쟁을 그냥 넘기는 겁니다. 이 데이터 프레임의 맨 위를 보면 데이터 프레임을 생성했을 때 예상할 수 있는 것과 매우 비슷하다는 것을 알 수 있을 겁니다.
1:14
그래서 여러분이 할 수 있는 한 가지는 메모리에 있는 모든 데이터를 보는 겁니다. 그래서 여러분은 테이블 명령을 이용해서 끝에는 s가 있고, 테이블 명령과는 다르다. 그러면 데이터 테이블의 이름, 행 수, 열의 수 및 키가 있는 경우 그래서 잠시 후에 열쇠가 무엇을 의미하는지에 대해 조금 더 이야기 할 겁니다. 여러분이 할 수 있는 첫 번째 일은 데이터 프레임의 행 하위 설정. 쉼표 앞에 있는 대괄호에서 첫 번째 점을 사용하여 부분 집합을 만들 수 있다. 또한 데이터 프레임에서 행한 것처럼 특정 요소 y에 액세스하여 y가 a와 같은 값만 살펴봄으로써 행의 하위 집합을 만들 수도 있다.
2:04
한 가지 다른 점은 하나의 색인으로 부분 집합할 때 행에 따라 부분 집합한다는 겁니다. 그래서 이 데이터 테이블을 만들 때, 두 번째 또는 세 번째 요소를 선택하게 되면, 그 데이터 테이블에서 나오는 두 번째와 세 번째 행을 택하게 될 겁니다.
2:20
열을 부분집합하려고 할 때, 데이터 프레임에서 익숙한 방식으로 열을 부분집합하려고 하면, 여기서 데이터 테이블과 데이터 프레임이 실제로 분산되는 겁니다. 실제로 데이터 프레임에서 발생하는 동일한 서브셋팅 함수를 사용하여 열의 부분 집합을 만드는 것이 아니라, 약간 다른 기능을 수행한다. 그래서 그것은 다양한 방법으로 데이터를 요약할 수 있는 표현들을 사용하고 있다. 그래서, 어떤 표현이든, 이렇게 구불구불한 괄호 사이에 있는 표현들 입니다. 여기 10번, 5번 인쇄라는 문장의 예가 있는데, 이것은 실제로 10번 인쇄하는 겁니다. 그러나 k에게 인쇄하라고 하면, 그것은 결국 변수 5를 출력한다. 그래서, 이것은 우리가 데이터 세트를 요약하기 위해 표현식을 사용하려 할 때, 곧 연극으로 나올 것이다.
3:06
예를 들어, 여기 괄호 안의 두 번째 부분에 인덱스를 넣는 대신, 실제로 함수가 열별로 지정된 변수에 적용되는 경우 수행할 함수 목록을 전달할 수 있다. 여기서 x는 데이터 표의 변수 중 하나이고 z는 데이터 표의 변수 중 하나이다. 그리고 괄호나, 죄송합니다, 따옴표를 사용할 필요가 없다는 것을 유의하십시오. 그것은 단지 변수들을 인식할 것이다. R을 사용하려 한다는 겁니다. 그래서, x 값의 평균과 z 값의 합을 보고하게 될 겁니다. 당신은 또한 거의 모든 기능을 수행하기 위해 그것을 할 수 있다. 예를 들어, y 값 표를 구하면 된다고 할 수 있다. 그래서 여러분이 이 두 번째 논쟁에 목록을 통과시킬 때마다, 그 기능들을 수행하게 되고, 그 값들을 돌려주게 될 겁니다. 그것은 데이터를 요약하는 데 좋다. 그것이 매우 빠르고 효율적으로 하는 또 다른 일은 새로운 열을 추가하는 것이다. 이 z 변수 제곱과 같은 새 열이 있는 데이터 테이블에 새 열을 추가하려는 경우 이 명령을 사용하여 데이터 테이블에 변수 w를 추가할 수 있다. 좋은 점은 데이터 프레임에 새로운 변수를 추가할 때 R은 전체 데이터 프레임에 복사하여 새 변수를 추가하므로 데이터 프레임과 메모리의 복사본 2개를 얻을 수 있다는 겁니다. 그래서 빅 데이터 세트를 다룰 때, 이것은 분명 많은 메모리 문제를 일으킬 것이다. 새로운 복사본이 만들어지지 않기 때문에 데이터 테이블에는 없는 것이다.
4:34
하지만 당신은 그것에 대해 조금 조심해야 한다. 그래서 우리가 첫 번째 데이터 테이블에 할당될 두 번째 데이터 테이블을 설정했다고 가정해보자. 그리고 첫 번째 데이터 테이블을 변경하십시오. 아직 사본이 만들어지지 않았기 때문에, 첫 번째 데이터 테이블을 살펴보면, 분명히 우리는 Y 변수를 모두 그러나 두 번째 데이터 테이블은 첫 번째 데이터 테이블로 할당되었고, 복사본이 만들어지지 않았기 때문에 실제로 데이터 테이블 2도 변경했다. 따라서 사본을 만들려면 복사 기능을 사용하여 명시적으로 만약 당신이 함수 카피를 사용한다면 당신은 데이터 테이블을 복사 할 수 있을 것이다.
5:16
다음으로 할 수 있는 것은 실제로 여러 단계 함수를 수행하여 새로운 변수를 만들 수 있다는 겁니다. 예를 들어 여기 어떤 표현이 있는데 보세요 그것은 곱슬머리판으로 시작하고 그것은 곱슬머리판으로 끝납니다. 그리고 각각의 진술 뒤에 세미콜론이 있다. 첫 번째 설명은 임시 변수인 X 더하기 Z의 값에 할당한 다음, 임시 변수 2에 5를 더해서 기억하시겠지만, 마지막 진술에 대한 평가에서 이 표현으로부터
5:51
그래서 결국 이 변수 m은 x+z+5의 로그 베이스 2에 할당될 것이다. 그래서 그러한 종류의 다단계 운영은 데이터 표로 매우 쉽게 처리될 수 있다.
6:06
당신은 또한 수술처럼 합주를 할 수 있다. 예를 들어, 이 데이터 테이블에 X가 0보다 크면 True이고 X가 0보다 작을 때 False와 같은 변수를 추가할 수 있다. 이제 우리는 함께 일할 수 있는 2진수 값 A를 가지고 있다. 따라서 X가 0보다 큰 경우와 X가 0보다 작은 경우를 비교하여 다른 변수를 요약한다고 가정합시다. 예를 들어 X + W의 평균을 취하여 변수 A로 그룹화할 수 있다. 그래서 그것이 할 일은 A가 진실일 때 X+W의 평균을 내고, A가 진실과 같은 모든 행에
6:51
그럼 A가 거짓과 같은 X+W의 평균이 되겠지 그리고 그것은 A가 거짓과 같은 모든 행에 배치한다. 즉, 4에서 사용한 변수에 대해 집계된 집계 평균과 동일한 새 변수를 생성하십시오. 어떤 일을 정말 빨리 할 수 있게 해주는 몇 가지 특별한 변수와 데이터 표가 있다. 하나는 .N이 연결된 정수고, 특정 그룹이 나타나는 격납 횟수입니다. 예를 들어, A, B, C가 많은 데이터 테이블을 만들었을 때 약 100,000 A와 C가 그 다음, 내가 할 수 있는 것은, 만약 내가 각각의 글자가 나타나는 횟수를 세고 싶다면, 나는 데이터 테이블, 점 N을 사용할 수 있고, 그리고 나서 X 변수를 기준으로 그룹화할 수 있다. 그리고 그 다음에는 그것이 계산될 것이고, 점 N은 X 변수를 기준으로 그룹화된 횟수를 세는 것이다.
7:52
그것은 DT 달러 기호 X의 표만 하는 등가 연산과 반대로 매우 빠르게 한다. 데이터 표의 독특한 측면은 그들이 키를 가지고 있다는 것이다. 그래서 만약 당신이 키를 설정하면, 당신이 데이터 프레임을 가지고 할 수 있는 것보다 훨씬 더 빨리 데이터 테이블을 소트하고 정렬할 수 있다. 여기서, 데이터 테이블을 만들고, 변수 X를 가지게 될 겁니다. 변수 Y를 가지고 있고, 데이터 테이블의 키를 변수 X로 설정해 놓을 겁니다. 만일 내가 x에 근거하여 부분 집합을 원하거나 여기에 인용된 것을 넣는다면, 키는 x이고, 그것은 매우 빠르게 a와 같은 x의 값으로 데이터를 대체한다.
8:38
또한 키를 사용하여 데이터 테이블 사이의 접합을 쉽게 할 수 있으므로, 여기서 나는 변수 X와 변수 Y가 있는 두 개의 데이터 테이블을 만들었으며, 이 경우 두 번째 데이터 테이블은 변수 Z를 가진다.
8:57
그래서 두 경우 모두 x와 같은 키를 그리고 나는 그것들을 함께 병합할 수 있다. 두 데이터 테이블에 대해 동일한 키를 가지고 있는 한, 이것은 데이터 프레임과 병합하는 것보다 훨씬 더 빠르다. 그것은 매우 빠를 수 있다.
9:17
디스크에서 데이터를 빠르게 읽을 수 있으려면 데이터 테이블을 사용하는 것이 유리할 수도 있다. 그래서 여기에 큰 데이터 프레임을 만들었다. 그래서 그것은 두개의 매우 큰 변수를 가진 데이터 프레임이다. 그리고 바로 여기에 이 명령어를 가진 임시 파일을 설치했다. 그리고 나는 그 파일을 우리의 빅 데이터 프레임 어플리케이션을 쓴다. 그리고 나서 나는 fread 명령을 사용하여 그것을 읽는 데 걸리는 시간을 정할 것이다. fread 명령은 기본적으로 read.table 탭으로 구분된 파일을 대체하는 드롭인처럼 데이터 테이블 읽기에 적용될 수 있다. 그리고 당신은 그것이 약 0.32초가 걸리는 것을 볼 수 있다.
9:57
만약 같은 작업을 시도한다면, 만약 그 파일을 읽으려고 노력한다면, 그 파일은 10배 이상 느리게 읽혀질 겁니다. 그래서 실제로 데이터, 데이터, 테이블로도 파일을 읽는 것이 훨씬 더 빠르다.
10:14
데이터 표를 요약하는 것은 데이터 프레임보다 더 빠르고 메모리 효율적일 수 있다. 비록 그것이 당신에게 약간의 사용 구문을 배우도록 요구하지만, 때때로 데이터 테이블을 복사하는 것에 있어서 약간의 조심스러운 것을 필요로 한다. 최근의 개발은 그 패키지의 개발 버전에서 찾을 수 있다. 바로 여기 이 웹사이트에서 찾을 수 있어 그들은 이미 데이터 테이블에 대한 운영과 같은 용해된 운영과 같은 작업을 개발하기 시작했고, 매우 빠르게 발전하는 패키지라는 것을 지속적으로 업데이트 할 것이다. 그리고 여기 이 웹사이트는 데이터.테이블과 데이터 프레임 간의 모든 차이를 포괄적으로 나열하는 목록을 제공하기 때문에 매우 좋은 것이다. 데이터 프레임을 사용하는 것에서 데이터 테이블을 사용하는 것으로 전환하는 경우 매우 유용할 겁니다.
10:59
오늘 내가 사용한 노트들은 대부분 라파엘 고타도가 여기 GitHub에 올려놓은 노트들에 기초하고 있고, 그것들은 원래 케빈 우쉬의 노트였습니다. 그리고 나는 두 노트 모두 내가 이 강의를 위해 복사한 훌륭한 음들에 대해 칭찬받을 만하다고 생각한다.